//
// 14503 로봇청소기
//
// 조건
// - N*M 크기의 직사각형 영역에 로봇청소기가 있다
// - 각 칸은 벽(1)과 빈칸(0)으로 이루어져있다.
// - 청소기는 동,서,남,북 방향 중 하나로 바라보고 있다.
// - 지도의 각 칸은 (r,c)로 나타낼 수 있고 r은 북쪽으로부터 떨어진 칸의 개수 ( row ) , c는 서쪽으로부터 떨어진 칸의 개수 ( column )을 의미한다
// - ** 로봇 청소기는 다음과 같이 작동한다 **
//		-> 현재 위치를 청소한다.
//		-> 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다
//		-> 왼쪽 방향에 청소할 공간이 있다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
//		-> 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다
//		-> 네 방향 모두 청소가 이미 되어 있거나 벽인 경우에는, 바라보는 방향을 유지한채로 한칸 "후진"을 하고 2번으로 돌아간다
//		-> 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
//		-> 로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.
// - 로봇청소기가 주어졌을때 청소하는 영역의 개수를 구하라
//
// 입력
// - 첫째줄 : 세로크기 N( 3<= N <= 50 ) 과 가로크기 M ( 3<= M <= 50 )
// - 둘째줄 : 로봇 청소기가 있는 칸의 좌표(r,c)와 바라보는 방향 d가 주어진다.
//		-> d == 0 북, d == 1 동, d == 2 남, d == 3 서
// - 셋째줄~N+2줄 : 청소의 상태가 북쪽부터 남쪽 순서대로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 
//		빈 칸은 0 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.
// - 로봇 청소기가 있는 칸의 첫 상태는 항상 빈 칸(청소해야할칸)이다.
//
// 접근
// - 재귀의 형태로 조건에서 주어진 로봇청소기의 동작조건을 구현
//
#include <iostream>
//로봇 청소기의 움직임에 대한 상수 정의
#define DIR_NORTH	0
#define DIR_EAST	1
#define DIR_SOUTH	2
#define DIR_WEST	3

using namespace std;

//로봇청소기가 움직일 맵 배열 선언 및 초기화
int map[50][50] = { 0 };
//로봇 청소기가 청소한 위치에 대한 배열 선언 및 초기화
int clean[50][50] = { 0 };
//로봇 청소기의 다음 위치에 대한 배열 선언 및 초기화
int dx[4] = { 0,1,0,-1 };
int dy[4] = { -1,0,1,0 };
// 북 동 남 서
//로봇청소기가 후진할 위치에 대한 배열 선언 및 초기화
int bx[4] = { 0,-1,0,1 };
int by[4] = { 1,0,-1,0 };
//맵의 크기에 대한 변수 선언 및 초기화
int N = 0, M = 0;
//결과값에 대한 선언 및 초기화
int res = 0;

//param x, y : 청소기의 위치
//param dir : 현재 청소기가 바라보고 있는 방향
//param rotate_num : 청소기의 회전 횟수
void cleaning(int x, int y, int dir, int rotate_num)
{
	//청소기의 다음 위치 및 다음 위치에서 바라볼 방향 변수 선언
	int xn, yn, n_dir;
	//1. 현재 위치가 청소하지 않은 곳이라면 청소 및 청소지역의 횟수 증가
	if (clean[y][x] == false)
	{
		clean[y][x] = true;
		res++;
	}

	//다음 탐색 방향 설정
	if(dir == 0 ) 
		n_dir = 3; 
	else 
		n_dir = dir - 1; 
	//다음 탐색방향의 위치 설정
	xn = x + dx[n_dir];
	yn = y + dy[n_dir];
	//2-c, 2-d "네방향 모두" 청소가 이미 되어있거나 벽인 경우
	if (rotate_num > 3)
	{
		//후진 위치 설정
		xn = x + bx[dir];
		yn = y + by[dir];
		//2-d, 후진 위치가 벽이라면 재귀 종료
		if (map[yn][xn] == 1)
			return;
		else
		{
			//후진이 가능하면 후진 위치로 이동, 방향은 현재 바라보는 방향을 그대로 유지
			cleaning(xn, yn, dir, 0);
			return;
		}
	}

	//2-a, 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면 그 방향으로 회전하고 다음 한칸을 전진
	if (map[yn][xn] == 0 && clean[yn][xn] == false)
		cleaning(xn, yn, n_dir, 0);
	//2-d, 왼쪽 방향에 청소할 공간이 없다면( 이미 청소했다면 ), 그 방향으로 회전하고 2번(재귀)으로 돌아간다
	else if (map[yn][xn] == 0 && clean[yn][xn] == true)
		cleaning(x, y, n_dir, rotate_num + 1);
	//2-d, 왼쪽 방향에 청소할 공간이 없다면( 벽이라면 ), 그 방향으로 회전하고 2번으로 돌아간다
	else if (map[yn][xn] == 1)
		cleaning(x, y, n_dir, rotate_num + 1);

	return;
}

int main(void)
{
	//맵 크기를 입력받는다
	cin >> N >> M;
	//초기 위치와 방향을 저장할 변수 선언 및 초기화
	int init_x = 0, init_y = 0, dir = 0;
	//초기 위치와 방향을 받아온다
	cin >> init_y >> init_x >> dir;
	//맵 정보를 받아온다
	for (int y = 0; y < N; y++)
	{
		for (int x = 0; x < M; x++)
		{
			cin >> map[y][x];
		}
	}
	//청소 시작
	cleaning(init_x, init_y, dir, 0);
	//결과 출력
	cout << res << endl;

}