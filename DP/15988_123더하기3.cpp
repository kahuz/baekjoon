//
// 정수 n이 주어졌을때 n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오
// 테케 T는 주어지지 않았지만 정수 n이 1,000,000의 값을 가질 수 있으므로
// 완전탐색 형태로는 시간복잡도를 해결할 수 없다
// 따라서 점화식을 세워 DP형태로 접근하도록 하자...
//
// DP 접근시 가장 간단하지만 무식한(?) 방법으로 주어진 수에 대한 경우를 쭉 써보자
//
// 1 : 1	, 2 : 1 1 ,		3 : 1 1 1 ,		4 : 1 1 1 1 ,	5 : ...
//				  2				1 2				1 1 2			...
//								2 1				1 2 1			...
//								3				1 3				.
//												2 1	1			.
//												2 2				.
//												3 1				...
// 쭉 쓸때 맨 앞자리의 수를 고정해서 나오는 경우들을 줄지어보면
// 4를 기준으로 1자리는 3의 경우, 2 자리는 2의 경우 3자리는 1의 경우가 된다
// 5 역시도 너무 길어서 생략했지만 1 자리는 4의 경우, 2 자리는 3의 경우, 3자리는 2의 경우로 구성된다
// 즉 dp[5] = dp[4] + dp[3] + dp[2] , dp[4] = dp[3] + dp[2] + dp[1] 이 되므로
// 1,2,3의 경우의 수만 알면 그 이후 값은 자동으로 알 수 있게 되는 것.
#include <iostream>
#include <vector>
using namespace std;
//결과 출력을 위한 모드값
#define MOD_VALUE 1000000009

//각 숫자에 대한 경우의 수를 저장할 배열. 0을 제외하고 사용, 경우의 수에 대한 데이터 타입을 생각할 것
long long dp[1000001] = { 0,1,2,4 };
//테스트 케이스 변수
int T = 0;

int main(void)
{
	//테스트케이스가 혹시나 백만개가 들어올지도 모르니 c++는 stdio 동기화를 풀어주자
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	
	cin >> T;

	//테스트 케이스만큼 루프
	while (T--)
	{
		int num = 0;
		cin >> num;

		//입력값이 4이상이면 dp배열에 값을 채워준다
		for (int i = 4; i <= num; i++)
		{
			dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD_VALUE;
		}
		//endl은 파이플인 동기화 제거과정이 있으므로 입출력이 많을땐 사용하지말것
		cout << dp[num] << "\n";
	}

	return 0;
}