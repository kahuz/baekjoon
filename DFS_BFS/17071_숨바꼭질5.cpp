// 17071 숨바꼭질5
// 조건
// - 수빈이와 동생이 숨바꼭질을 하고 있다. 수빈이는 0 <= N <= 500,000 위치에, 동생은 0 <= K <= 500,000 위치에 있다
// - 수빈이는 걷기와 순간이동이 가능하며 움직이는 조건은 아래와 같다
// -> 1. 걷기로 이동가능하며 걷기는 " X일때 X-1 혹은 X+1 이동"을 의미
// -> 2  순간이동으로 이동이 가능하며 순간이동은 " 2*x 위치로 이동"을 의미.
// - 동생 또한 걷기가 가능하며, 매초마다 이동에 가속이 붇는다
// -> 즉, K위치에서 시작시 K+1, K+1+2, K+1+2+3 .. 식으로 증가한다
// - 수빈이와 동생의 위치가 주어졌을때 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇초인지 구하라
// - "제한시간 0.25초"
//
// 입력
// - 수빈이의 위치 N과 동생의 위치 K가 주어진다
//
// 접근법
// - 수빈이와 동생의 위치를 입력받는다
// - 입력받은 값을 통해 한번의 loop 동안 아래와 같이 동생의 위치 갱신과 수빈이의 BFS 탐색을 한다
// - 동생의 위치 K를  K = K + (n += (n+1))로 갱신한다
// - 수빈이는 BFS탐색으로 동생의 위치에 도달한지 확인하고 BFS 탐색은 수빈이의 위치 N에 대해
//   N = (N-1) , (N+1) , (N * 2 ) 세 방향으로 탐색을 추가한다 ( 단순 접근으로 보아도 시간제한 0.25초에 부가 )
//
// 풀이법을 통한 접근
//
// - 우선 위에 언급한 단순한 BFS탐색으로는 시간초과로 불가능하다는 것을 확인
// - 1. 대표적인 숨바꼭질5의 풀이의 힌트는 수빈이의 도착 시간을 기준으로 동생을 잡아내는 방식이다
// - 2. 즉, 동생의 위치에 도달했는지를 찾는게 아닌 동생이 수빈이의 위치에 도착하는 것을 기준으로 삼는 것
// - 3. 동생이 수빈이의 위치에 도착했을때가 짝수 초인지 홀수 초인지를 구분하는 것
// - 4. 그 외에 동시에 같은 위치에 도달할 수 있으므로, 그 상황에 대해서도 추가해주었다
// - 위 1,2,3번을 이해하고 로직을 설계한다면 쉽게 접근 가능. 이를 생각하지 못한다면 시간초과를 면하기 힘들 것으로 보임
//

#include <iostream>	//io
#include <queue>	//queue

using namespace std;
//수빈이의 움직임을 위한 배열 선언 및 초기화
int dx[3] = { -1, 1, 0 };
int dm[3] = { 1,1,2 };
//홀수 시간과 짝수 시간에 대해 위치 도달을 확인하기 위한 배열 선언 및 초기화
int check[2][500001] = { 0 };

//수빈이의 위치를 탐색할 bfs 큐 선언
queue<int> bfs_q;
//수빈이와 동생의 초기 위치
int N = 0, K = 0;
//결과 변수 선언 및 초기화, bfs 탐색 결과 res를 갱신하지 못했다면 만나지 못한 것으로 간주, -1을 반환
int res = -1;

void bfs(int start_pos)
{
	//탐색 시작 위치를 큐에 삽입
	bfs_q.push(start_pos);
	//탐색 시작 위치를 표시, 아직 움직이지 않은 시작 위치기에 짝수 배열에 표시
	check[0][start_pos] = 1;

	//동생이 이동하는 거리의 기준이 되는 시간 변수 선언 및 초기화
	int time = 1;

	while (!bfs_q.empty())
	{
		//동생의 위치 갱신
		K += time;

		//동생의 위치가 배열 범위를 벗어나면 종료
		if (K > 500000) return;

		//동생의 이동 시간을 기준으로 홀수초,짝수초에 해당 위치 방문을 확인
		//check의 홀수 혹은 짝수 배열의 해당 위치(K)에 수빈이가 '먼저' 도달했다는 것은
		//x+1, x-1 탐색을 통해 동생이 K에 도달하는 것을 기다릴 수 있으므로
		//현재 time 값을 리턴해준다
		if (check[time % 2][K]) {
			res = time;
			return;
		}

		int size = bfs_q.size();
		//수빈이의 다음 초 이동경로 탐색 시작
		for (int i = 0; i < size; i++)
		{
			//현재 위치를 받아온 뒤 값을 반환한 노드는 반납
			int x = bfs_q.front();
			bfs_q.pop();

			//x-1 x+1 x*2 위치에 대한 탐색 시작
			for (int i = 0; i < 3; i++)
			{
				//다음 위치 값을 계산
				int xn = (x + dx[i]) * dm[i];

				//탐색 위치가 현재 동생이 있는 위치라면 time을 res에 저장
				//현재 탐색이 다음 초에 대한 탐색이지만
				//수빈이는 time을 1로 시작하였기에 time값을 그대로 res에 저장한다
				if (xn == K)
				{
					res = time;
					return;
				}
				//탐색 위치가 배열 범위를 벗어나면 continue
				if (xn < 0 || xn > 500000) continue;
				//탐색 위치가 이미 방문한 곳이라면 continue
				if (check[time % 2][xn])	continue;
				//탐색 가능한 위치라면 방문 표시와 함께 큐에 탐색 위치를 넣는다
				check[time % 2][xn] = true;
				bfs_q.push(xn);
			}
		}
		time++;
	}
}

int main(void)
{
	//수빈이와 동생의 시작 위치를 받아온다
	cin >> N >> K;
	//시작 위치가 같으면 바로 잡으므로 0 반환
	if (N == K)
	{
		cout << 0 << endl;
		return 0;
	}
	//bfs 탐색 시작
	bfs(N);
	//결과값 반환
	cout << res << endl;
	return 0;
}